// Fonction pour g√©n√©rer une matrice 5x5 remplie de z√©ros
function generateMatrix() {
    return Array.from({ length: 5 }, () => Array(5).fill('üî≤'));
}

// Fonction pour g√©n√©rer une matrice 5x5 remplie de z√©ros
function generateMatrixRandom() {
    const symbols = ['‚¨ÜÔ∏è', '‚û°Ô∏è', '‚¨ÖÔ∏è', '‚¨áÔ∏è', 'üî≤', 'üî≤', 'üî≤', 'üî≤', '‚îò', '‚îî', '‚îê', '‚îå'];
    return Array.from({ length: 5 }, () => Array.from({ length: 5 }, () => symbols[Math.floor(Math.random() * symbols.length)]));
}

// Fonction pour v√©rifier si une position est valide dans la matrice et n'a pas √©t√© visit√©e
function isValidPosition(x, y, visitedPositions) {
    return x >= 0 && x < 5 && y >= 0 && y < 5 && !visitedPositions.has(`${x},${y}`);
}

// Fonction pour g√©n√©rer un chemin al√©atoire dans la matrice
function generateRandomPath() {
    const directions = ['‚¨ÜÔ∏è', '‚û°Ô∏è', '‚¨ÖÔ∏è', '‚¨áÔ∏è']; // Haut, Droite, Gauche, Bas

    let path = [];
    let currentX = 0;
    let currentY = 0;
    let visitedPositions = new Set(); // Ensemble des positions visit√©es

    // Choisir al√©atoirement le d√©but du chemin (DD ou DB)
    const startDirection = Math.random() < 0.5 ? 'DD' : 'DB';
    visitedPositions.add(`${currentX},${currentY}`); // Ajouter la position de d√©part aux positions visit√©es    
    if (startDirection === 'DD') {
        currentX++;
    } else {
        currentY++;
    }
    path.push(startDirection);

    while (true) {
        let direction;
        do {
            direction = directions[Math.floor(Math.random() * directions.length)]; // Choisir une direction al√©atoire
        } while (!isValidPosition(currentX, currentY, visitedPositions)); // Continuer √† choisir une direction jusqu'√† ce qu'elle soit valide

        // Ajouter la nouvelle position aux positions visit√©es
        visitedPositions.add(`${currentX},${currentY}`);

        path.push(direction);

        // Mettre √† jour les coordonn√©es en fonction de la direction choisie
        if (direction === '‚¨ÜÔ∏è') currentY--;
        else if (direction === '‚û°Ô∏è') currentX++;
        else if (direction === '‚¨ÖÔ∏è') currentX--;
        else if (direction === '‚¨áÔ∏è') currentY++;

        if (!isValidPosition(currentX, currentY, visitedPositions)) break;
    }

    path[path.length - 1] = 'üèÅ';

    if (path.length < 5) {
        return generateRandomPath();
    }
    else {
        return path;
    }
}

// Fonction pour mettre √† jour la matrice avec les rotations
function updateMatrixWithPath(matrix, path) {
    let currentX = 0;
    let currentY = 0;

    path.forEach((direction, index) => {
        matrix[currentY][currentX] = direction;

        // V√©rifier s'il s'agit d'une direction autre que le d√©but du chemin
        if (index > 0) {
            const prevDirection = path[index - 1];
            let corner;
            if ((prevDirection ==='DB' && direction ==='‚û°Ô∏è' || prevDirection === '‚¨ÖÔ∏è' && direction === '‚¨ÜÔ∏è') || (prevDirection === '‚¨áÔ∏è' && direction === '‚û°Ô∏è')) {
                corner = '‚îî';
            } else if ((prevDirection === '‚¨ÜÔ∏è' && direction === '‚û°Ô∏è') || (prevDirection === '‚¨ÖÔ∏è' && direction === '‚¨áÔ∏è')) {
                corner = '‚îå';
            } else if ((prevDirection ==='DD' && direction ==='‚¨áÔ∏è' || prevDirection === '‚û°Ô∏è' && direction === '‚¨áÔ∏è') || (prevDirection === '‚¨ÖÔ∏è' && direction === '‚¨ÜÔ∏è')) {
                corner = '‚îê';
            } else if ((prevDirection === '‚û°Ô∏è' && direction === '‚¨ÜÔ∏è') || (prevDirection === '‚¨áÔ∏è' && direction === '‚¨ÖÔ∏è')) {
                corner = '‚îò';
            } else if (direction == 'üèÅ'){
                switch (prevDirection){
                    case '‚û°Ô∏è':
                        matrix[currentY][currentX] = "GüèÅ";
                        break;

                    case '‚¨áÔ∏è':
                        matrix[currentY][currentX] = "HüèÅ";
                        break;

                    case '‚¨ÖÔ∏è':
                        matrix[currentY][currentX] = "DüèÅ";
                        break;

                    case '‚¨ÜÔ∏è':
                        matrix[currentY][currentX] = "BüèÅ";
                        break;
                }
            }

            if (corner) {
                matrix[currentY][currentX] = corner;
            }
        }

        if (direction === 'DD') currentX++;
        else if (direction === 'DB') currentY++;
        else if (direction === '‚¨ÜÔ∏è') currentY--;
        else if (direction === '‚û°Ô∏è') currentX++;
        else if (direction === '‚¨ÖÔ∏è') currentX--;
        else if (direction === '‚¨áÔ∏è') currentY++;
    });

    // Appliquer les rotations sur chaque cellule

    matrix.forEach((row, rowIndex) => {
        row.forEach((cell, colIndex) => {
            if (cell !== 'GüèÅ' && 
            cell !== 'HüèÅ' && 
            cell !== 'DüèÅ' && 
            cell !== 'BüèÅ' && 
            cell !== 'DD' && 
            cell !== 'DB' && 
            cell != 'üî≤') {
                matrix[rowIndex][colIndex] = rotateCell(cell);
            }
        });
    });

    return matrix;
}

// Fonction pour g√©rer le clic sur une case
function handleClick(x, y) {
    let currentValue = matrixWithPath[y][x];
    if (currentValue === 'üèÅ' || currentValue === 'DD' || currentValue === 'DB' || currentValue==='üî≤' ) {
        return;
    }
    let newValue = rotateCell(currentValue, false);
    matrixWithPath[y][x] = newValue;
    updateMatrixDisplay();
}


// Fonction pour mettre √† jour l'affichage de la matrice
function updateMatrixDisplay() {
    let html = '';
    matrixWithPath.forEach((row, rowIndex) => {
        html += '<div>';
        row.forEach((cell, colIndex) => {
            if (cell === 'GüèÅ' ||
            cell === 'HüèÅ' ||
            cell === 'DüèÅ' ||
            cell === 'BüèÅ' ||
            cell === 'DD' || 
            cell === 'DB') {
                html += `<span>${cell}</span>`;
            } else {
                html += `<span onclick="handleClick(${colIndex}, ${rowIndex})">${cell}</span>`;
            }
        });
        html += '</div><br>';
    });
    document.querySelector("#resultat").innerHTML = html;
}

// Fonction pour effectuer une rotation al√©atoire ou fixe sur une cellule
function rotateCell(cell, random = true) {
    const rotations = random ? Math.floor(Math.random() * 4) : 1;
    let rotatedCell = cell;
    for (let i = 0; i < rotations; i++) {
        switch (rotatedCell) {
            case '‚¨ÜÔ∏è':
                rotatedCell = '‚û°Ô∏è';
                break;
            case '‚û°Ô∏è':
                rotatedCell = '‚¨áÔ∏è';
                break;
            case '‚¨áÔ∏è':
                rotatedCell = '‚¨ÖÔ∏è';
                break;
            case '‚¨ÖÔ∏è':
                rotatedCell = '‚¨ÜÔ∏è';
                break;
            case '‚îå':
                rotatedCell = '‚îî';
                break;
            case '‚îî':
                rotatedCell = '‚îò';
                break;
            case '‚îò':
                rotatedCell = '‚îê';
                break;
            case '‚îê':
                rotatedCell = '‚îå';
                break;
            default:
                rotatedCell = cell;
        }
    }
    return rotatedCell;
}


//G√©n√©rer une matrice al√©atoire
const randomMatrix = generateMatrixRandom();

// G√©n√©rer la matrice
const path = generateRandomPath();
console.log(path);

// Mettre √† jour la matrice avec le chemin et les rotations
const matrixWithPath = updateMatrixWithPath(randomMatrix, path);
console.log(matrixWithPath) ;
// Appeler la fonction pour afficher la matrice initiale
updateMatrixDisplay();


function findPath(matrix) {
    const end = { x: -1, y: -1 };
    const start = { x: -1, y: -1 };
    const directions = { 
        'DD': 'right', 
        'DB': 'down', 
        '‚¨ÜÔ∏è': 'up', 
        '‚û°Ô∏è': 'right', 
        '‚¨ÖÔ∏è': 'left', 
        '‚¨áÔ∏è': 'down', 
        '‚îå': ['down', 'right'], 
        '‚îê': ['down', 'left'], 
        '‚îî': ['up', 'right'], 
        '‚îò': ['up', 'left']
    };
    const moves = { 'down': { x: 0, y: 1 }, 'up': { x: 0, y: -1 }, 'right': { x: 1, y: 0 }, 'left': { x: -1, y: 0 } };

    // Find the start and end points
    for (let i = 0; i < matrix.length; i++) {
        for (let j = 0; j < matrix[i].length; j++) {
            if (matrix[i][j] === 'üèÅ') {
                end.x = j;
                end.y = i;
            } else if (matrix[i][j] === 'DD' || matrix[i][j] === 'DB') {
                start.x = j;
                start.y = i;
            }
        }
    }

    console.log(start,end);

    // If start or end points not found, return false
    if (end.x === -1 || end.y === -1 || start.x === -1 || start.y === -1) {
        return false;
    }

    let current = { x: start.x, y: start.y, direction: directions[matrix[start.y][start.x]],};

    while (true) {
        const move = moves[current.direction];
        current.x += move.x;
        current.y += move.y;
        console.log(current);
        // Check if we have reached the end
        if (current.x === end.x && current.y === end.y) {
            return true;
        }

        // Check if the move is within the matrix boundaries
        if (current.x < 0 || current.x > matrix.length || current.y < 0 || current.y > matrix[current.x].length) {
            return false;
        }
        
        // Check if the next move is valid (no change in direction for consecutive moves)
        const nextDirectionSymbol = matrix[current.y][current.x];
        

        const nextDirection = Array.isArray(directions[nextDirectionSymbol]) ? 
            chooseDirection(directions[nextDirectionSymbol], current.direction) : 
            directions[nextDirectionSymbol];

        console.log(nextDirectionSymbol,nextDirection);

        if (!nextDirection) {
            // Unknown direction symbol, cannot proceed
            return false;
        }


        current.direction = nextDirection;
        console.log('fin boucle')
    }
}

function chooseDirection(possibleDirections, currentDirection) {
    // Check if the current direction is one of the possible directions at the corner
    if (possibleDirections.includes(currentDirection)) {
        // If yes, continue in the current direction
        return currentDirection;
    } else {
        // Otherwise, choose the other direction
        return possibleDirections.find(direction => direction !== currentDirection);
    }
}

// Exemple d'utilisation
const matrix1 = [
    ['DB', 'üèÅ', '‚îî', '‚û°Ô∏è', '‚¨ÜÔ∏è'],
    ['‚îê', '‚îò', '‚¨ÖÔ∏è', 'üî≤', '‚¨áÔ∏è'],
    ['‚îå', '‚îê', 'üî≤', 'üî≤', 'üî≤'],
    ['üî≤', '‚îê', 'üî≤', '‚îò', '‚îê'],
    ['üî≤', '‚îò', '‚îå', '‚¨ÜÔ∏è', 'üî≤']
];

const matrix2 = [
    ['DB', 'BüèÅ', '‚îî', '‚û°Ô∏è', '‚¨ÜÔ∏è'],
    ['‚îî', '‚îò', '‚¨ÖÔ∏è', 'üî≤', '‚¨áÔ∏è'],
    ['‚îå', '‚îê', 'üî≤', 'üî≤', 'üî≤'],
    ['üî≤', '‚îê', 'üî≤', '‚îò', '‚îê'],
    ['üî≤', '‚îò', '‚îå', '‚¨ÜÔ∏è', 'üî≤']
];

const matrix3 = [
    ['DD', '‚û°Ô∏è', '‚û°Ô∏è', '‚û°Ô∏è', '‚îê'],
    ['‚îî', '‚îò', '‚¨ÖÔ∏è', 'üî≤', 'HüèÅ'],
    ['‚îå', '‚îê', 'üî≤', 'üî≤', 'üî≤'],
    ['üî≤', '‚îê', 'üî≤', '‚îò', '‚îê'],
    ['üî≤', '‚îò', '‚îå', '‚¨ÜÔ∏è', 'üî≤']
];

console.log(findPath(matrix1)); // Renvoie true s'il existe un chemin entre le d√©but et la fin
// console.log(findPath(matrix2));
// console.log(findPath(matrix3));